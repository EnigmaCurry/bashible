#!/usr/bin/env bash

# bashible
# (c) Jan Molic 2020
# https://github.com/mig1984/bashible

ble_version() {
  echo 0.2
}

### INTERNAL FUNCTIONS ####

ble_help() {
  echo "bashible version $(ble_version)"
  echo
  echo "usage: bashible ./script.ble"
  echo
  echo "see also: https://github.com/mig1984/bashible"
  echo
  echo "special exitcodes:"
  echo "  42   already handled failure (supress further error output in parental scripts)"
  echo "  43   means halt (it stops execution also in parental scripts)"
  echo "  143  when terminated by TERM, QUIT, INT or HUP"
  echo
  ble_exit 1
}

ble_exit() {
  _FINISHED=1
  exit $1
}

ble_print_start() {
  echo -e "\n\033[1;37;45m ${_BLE_NAV} \033[1;37;44m START \033[0m\n" >&2
}

ble_print_block() {
  echo -e "\n\033[1;37;45m ${_BLE_NAV} \033[1;37;44m $* \033[0m\n" >&2
}

ble_print_task() {
  echo -e "\033[37m - "$*" \033[0m" >&2
}

ble_print_fail() {
  echo -e "\n\033[1;37;45m ${_BLE_NAV} \033[1;37;41m $* \033[0m\n" >&2
}

ble_print_finish() {
  echo -e "\n\033[1;37;45m ${_BLE_NAV} \033[1;37;44m $BASHPID FINISH \033[0m\n" >&2
}

ble_print_continues() {
  echo -e "\033[1;37;45m ${_BLE_NAV} \033[1;37;44m ... \033[0m\n" >&2
}

ble_do_finish() {
  if (($1==0 || $1==43)); then
    ble_print_finish
  else
    if ((_FINISHED==0 && $1!=42)); then
      ble_print_fail "Unhandled failure, exit code $1 (PID=$BASHPID, CWD is $PWD)"
    fi
  fi
}

ble_trap_exit_top() {
  trap "rm \"\${_BLE_ALREADY}\" \"\${_BLE_DELAYED}\"" EXIT
}

ble_trap_exit() {
  trap "ble_do_finish \$?" EXIT
}

ble_trap_termination(){
  trap "
    if toplevel && ((\$$==\$BASHPID)); then
      # in the toplevel script and not it's subshell
      ble_print_fail \"process terminated, sending TERM to all processes in my process group \$\$\"
      trap - SIGHUP SIGINT SIGQUIT SIGTERM
      kill -TERM -\$\$
    fi
    ble_exit 42
    " SIGHUP SIGINT SIGQUIT SIGTERM
}

ble_serialize_command() {
  oldIFS=$IFS
  IFS=$'\t'; echo -e "$PWD\t$*"
  IFS=$oldIFS
}

ble_check_cmd() {
  quiet type "$1" || fail "command '$@' not found (CWD is $PWD)"
}

ble_handle_failure() {
 local ex=$1
 shift
 if ((ex>0)); then
   if ((ex!=42 && ex!=43)); then
     fail "command '$@' failed with exit code $ex (CWD is $PWD)"
   else
     ble_exit $ex
   fi
 fi
}

### CORE FUNCTIONS ###

@() {
  _SKIP=0
  cd "${_BASE_DIR}" || fail "can't chdir to base dir '${_BASE_DIR}'"
  ble_print_block "$*"
}

-() {
  if test $# -eq 0; then
    if ((_SKIP==0)); then
      print_info "loop"
      return 1
    else
      return 0
    fi
  fi

  if ((_SKIP!=1)); then
    ble_print_task "$*"
    ble_check_cmd "$1"
    _WHEN_USED=0
    local ex=0
    "$@" || ex=$?
    if ((_WHEN_USED==1)); then    # when has been used
      ((ex!=0)) && _SKIP=1        # set skip mode depending on the status
      return 0                    # and return 0
    else
      ble_handle_failure $ex "$@"
    fi
  fi
}

absolute_path() {
  local path
  if egrep -e '^\s+\./' <<< $1; then
    # $1 is a relative path
    path="$(cd $(dirname $1); pwd)/$(basename $1)"
  else
    # $1 is an absolute path or a command (without a path)
    path=$1
  fi
  test ${#path} -gt 0 || fail "absolute_path empty on '$1'"
  echo "$path"
}

base_dir() {
  _BASE_DIR=`absolute_path "$1"`
  if test ${#_BASE_DIR} -eq 0; then
    fail "base_dir: absolute_path '$1' failed"
  fi
  cd "${_BASE_DIR}" || fail "can't chdir to base dir '${_BASE_DIR}'"
}

ble_run_script() {
  ble_print_start
  _FINISHED=0
  source "$1"
  # unless it gets here, unhandled exit happened -> the exit handler will react on it because _FINISHED will be still set to 0
  _FINISHED=1
}

ble_set_nav_and_level() {
  let _BLE_LEVEL=${_BLE_LEVEL}+1
  if test ${#_BLE_NAV} -eq 0 ; then
    _BLE_NAV="`basename ${_SCRIPT_PATH} | sed "s/\.ble\$//" `"
  else
    _BLE_NAV="${_BLE_NAV} -> `basename ${_SCRIPT_PATH} | sed "s/\.ble\$//" `"
  fi
}

call() {
  (
     ble_set_nav_and_level
     export _BLE_LEVEL
     export _BLE_NAV
     ble_trap_termination
     ble_trap_exit
    # set -eu -o pipefail +m  # FIXME: really inherited?
     ble_run_script "$@"
  )
  local ex=$?
  if ((ex>0)); then
    return $ex
  else
    test ${#_BLE_NAV} -gt 0 && ble_print_continues
    return 0
  fi
}

delayed() {
  ble_serialize_command "$@" >> "${_BLE_DELAYED}" || fail "can't write to _BLE_DELAYED file (${_BLE_DELAYED})"
}

dir_empty() {
  local buf
  buf=` ls -A $1 | wc -l ` || ble_handle_failure $? "$@"
  ((buf>0))
}

empty() {
  ble_check_cmd "$1"
  local buf
  buf=` "$@" || return $? ` || ble_handle_failure $? "$@"
  test ${#buf} -eq 0
}

evaluate() {
  eval "$@" || return $?  # || is here to bypass the pipefail exit
}

fail() {
  if test $# -eq 0; then
    ble_print_fail "execution failed"
  else
    ble_print_fail $*
  fi
  ble_exit 42
}

finish() {
  if test $# -eq 0; then
    print_info "finishing execution of the script"
  else
    print_info $*
  fi
  ble_exit 0
}


fill_var() {
  local var=$1
  shift
  ble_check_cmd "$1"
  local buf
  buf=` "$@" || return $? ` || ble_handle_failure $? "$@"
  print_info "$var=$buf"
  eval "$var=\$buf"
}

halt() {
  if test $# -eq 0; then
    print_info "halting execution of this script and all parent scripts"
  else
    print_info $*
  fi
  ble_exit 43
}

may_fail() {
  # but still exit if the command does not exist
  ble_check_cmd "$1"
  "$@" || return 0
}

not() {
  ble_check_cmd "$1"
  "$@" && return 1 || return 0
}

output_to() {
  local dest=$1
  shift
  test "${#dest}" -gt 0 || fail "output_to: no destination file specified"
  ble_check_cmd "$1"
  if "$@" > $dest.tmp || ble_handle_failure $? "$@"; then
    mv "$dest.tmp" "$dest"
  else
    rm "$dest.tmp" 2>/dev/null
    return 1
  fi
}

orig_dir() {
  echo $ORIG_DIR
}

print_error() {
  echo -e "   \033[31m($*)\033[0m" >&2
}

print_warn() {
  echo -e "   \033[31m($*)\033[0m" >&2
}

print_info() {
  echo -e "   \033[32m($*)\033[0m" >&2
}

quiet() {
  "$@" >/dev/null 2>&1 || return $?
}

reset_base_dir() {
  _BASE_DIR=${_ORIG_BASE_DIR}
  cd "${_BASE_DIR}"
}

result() {
  local name=$1
  shift
  ble_check_cmd "$1"
  local ex=0
  "$@" || ex=$? # || is here to bypass pipefail exit
  eval "$name() {
    if test \$# -gt 0; then
      test \"$ex\" \"\$@\"; # with arguments
    else
      return \"$ex\"
    fi
  }"
}

set_var() {
  eval "$1=\$2"
}

toplevel() {
  ((_BLE_LEVEL==1))
}

var_empty() {
  local var=$1
  eval "test \${#$var} -eq 0"
}

when() {
  _WHEN_USED=1
  "$@" || return $?  # || is here to bypass the pipefail exit
}

unless_already() {
  local cmd=$1
  shift
  local path=`absolute_path "$cmd"`
  local scmd=`ble_serialize_command "$path" "$@"`
  if ! grep -q "$scmd" < ${_BLE_ALREADY}; then
    echo "$scmd" >> "${_BLE_ALREADY}" || fail "can't write to _BLE_ALREADY file (${_BLE_ALREADY})"
    "$path" "$@" || return $?
  fi
}

use() {
  for i in "$@"; do
    source "${_BLE_DIR}/bashible.$i" || fail "use: can't load ${_BLE_DIR}/bashible.$i"
  done
}

################
#### START #####
################

# help?
if test "$1" = -h -o "$1" = --help ; then
  ble_help
  exit 0
fi

# no script passed?
if test ${#1} -eq 0; then
  ble_help
  exit 1
fi

# variables inherited from the parent
_BLE_LEVEL=${_BLE_LEVEL}     # magic :-)
_BLE_NAV=${_BLE_NAV}
_BLE_ALREADY=${_BLE_ALREADY}
_BLE_DELAYED=${_BLE_DELAYED}

# now we can set defaults to be strict
set -eu -o pipefail +m

_ORIG_DIR=` pwd `
_BLE=` absolute_path "$0" ` # the bashible script itself
test ${#_BLE} -gt 0 || fail "can't get _BLE; is 'readlink' command present?"
_BLE_DIR=` dirname "${_BLE}" `  # bashible modules reside there
test ${#_BLE_DIR} -gt 0     || fail "can't get _BLE_DIR; is 'dirname' command present?"
test ` basename "${_BLE}" ` = bashible || fail "the 'basename' command is probably not present"
_SCRIPT_PATH=`absolute_path "$1"`
shift
_BASE_DIR=`dirname "${_SCRIPT_PATH}"`
_ORIG_BASE_DIR=${_BASE_DIR}

cd "${_BASE_DIR}" || fail "can't enter base dir '${_BASE_DIR}'"

_SKIP=0                      # skipping mode? will be reset on a next block
_WHEN_USED=0                 # "-" will set skipping mode depending on the final result
_FINISHED=0                  # to detect unhandled exits (pipefail)

ble_set_nav_and_level
ble_trap_termination
ble_trap_exit_top

if toplevel; then

  # this is the top-level script

  export _BLE_DELAYED=$(mktemp) # store commands called at the end
  test ${#_BLE_DELAYED} || fail "_BLE_DELAYED tempfile can not be created, is the 'mktemp' command present?"
  export _BLE_ALREADY=$(mktemp) # store already called commands
  test ${#_BLE_ALREADY} || fail "_BLE_ALREADY tempfile can not be created, is the 'mktemp' command present?"

  # this is the toplevel script
  # will be run in on the background, because the top process must be able to catch TERM and react immediately
  (
    export _BLE_LEVEL
    export _BLE_NAV

    ble_trap_termination
    ble_trap_exit
    ble_run_script "./`basename "${_SCRIPT_PATH}"`" "$@"
    test $? -ne 0 && ble_exit $? # test must be split from the run_script to enable exit on pipefail

    # run delayed commands
    # (they will exit immediately on failure unless prefixed by "may_fail")
    if test -s "${_BLE_DELAYED}"; then
      export _BLE_NAV='DELAYED'
      ble_print_start
      IFS=$'\n'; while read line; do
        readarray -d $'\t' -t ary <<< $line
        cd "${ary[0]}"      # original CWD
        ary=("${ary[@]:1}") # shift
        - "${ary[@]}"       # run the command with arguments via '-'
      done < "${_BLE_DELAYED}"
      ble_print_finish
    fi

  ) &
  wait -n
  ble_exit $?

else

  # this is a child script

  export _BLE_LEVEL
  export _BLE_NAV

  ble_trap_termination
  ble_trap_exit
  ble_run_script "./`basename "${_SCRIPT_PATH}"`" "$@"
  ble_exit $?

fi
